namespace Xunit
{
    using System;
    using System.Collections.Generic;
    using System.Reflection;

    /// <summary>
    /// Generates all values between two specified values
    /// </summary>
    public sealed class RangeAttribute : ParameterValuesAttribute
    {
        private Func<Type, IEnumerable<object>> Generator { get; }

        /// <summary>
        /// Indicates that all integer values between <paramref name="lowerBound"/> and <paramref name="upperBound"/> inclusive should be generated
        /// </summary>
        /// <param name="lowerBound">The integer to start generating from</param>
        /// <param name="upperBound">The integer to stop generating at</param>
        public RangeAttribute(long lowerBound, long upperBound)
            : this(lowerBound, upperBound, 1L)
        {
        }

        /// <summary>
        /// Indicates that all <paramref name="step"/>'th integer value between <paramref name="lowerBound"/> and <paramref name="upperBound"/> inclusive should be generated
        /// </summary>
        /// <param name="lowerBound">The integer to start generating from</param>
        /// <param name="upperBound">The integer to stop generating at</param>
        /// <param name="step">The amount to increase the value by at each generation step</param>
        /// <remarks>
        /// If <paramref name="lowerBound"/> is greater than <paramref name="upperBound"/> they will automatically switch.
        /// <paramref name="lowerBound"/> (or <paramref name="upperBound"/> if switched) will always appear in the sequence, however the other parameter will not necessarily appear if it is not in the sequence generated by continually adding <paramref name="step"/>.
        /// </remarks>
        public RangeAttribute(long lowerBound, long upperBound, long step)
        {
            if (step <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepMustBePositive, nameof(step)));
            }

            Generator = type => GetRangeSequenceFromLong(type, lowerBound, upperBound, step);
        }

        /// <summary>
        /// Indicates that all integer values between <paramref name="lowerBound"/> and <paramref name="upperBound"/> inclusive should be generated
        /// </summary>
        /// <param name="lowerBound">The integer to start generating from</param>
        /// <param name="upperBound">The integer to stop generating at</param>
        public RangeAttribute(ulong lowerBound, ulong upperBound)
            : this(lowerBound, upperBound, 1)
        {
        }

        /// <summary>
        /// Indicates that all <paramref name="step"/>'th integer value between <paramref name="lowerBound"/> and <paramref name="upperBound"/> inclusive should be generated
        /// </summary>
        /// <param name="lowerBound">The integer to start generating from</param>
        /// <param name="upperBound">The integer to stop generating at</param>
        /// <param name="step">The amount to increase the value by at each generation step</param>
        /// <remarks>
        /// If <paramref name="lowerBound"/> is greater than <paramref name="upperBound"/> they will automatically switch.
        /// <paramref name="lowerBound"/> (or <paramref name="upperBound"/> if switched) will always appear in the sequence, however the other parameter will not necessarily appear if it is not in the sequence generated by continually adding <paramref name="step"/>.
        /// </remarks>
        public RangeAttribute(ulong lowerBound, ulong upperBound, ulong step)
        {
            if (step <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepMustBePositive, nameof(step)));
            }

            Generator = type => GetRangeSequenceFromULong(type, lowerBound, upperBound, step);
        }

        /// <summary>
        /// Indicates that float values between <paramref name="lowerBound"/> and <paramref name="upperBound"/> inclusive should be generated with an increase of <paramref name="step"/> after every value
        /// </summary>
        /// <param name="lowerBound">The value to start generating from</param>
        /// <param name="upperBound">The value to stop generating at</param>
        /// /// <param name="step">The amount to increase the value by at each generation step</param>
        /// <remarks>
        /// If <paramref name="lowerBound"/> is greater than <paramref name="upperBound"/> they will automatically switch.
        /// <paramref name="lowerBound"/> (or <paramref name="upperBound"/> if switched) will always appear in the sequence, however the other parameter will not necessarily appear if it is not in the sequence generated by continually adding <paramref name="step"/>.
        /// </remarks>
        public RangeAttribute(float lowerBound, float upperBound, float step)
        {
            if (step <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepMustBePositive, nameof(step)));
            }

            Generator = type => GetRangeSequenceFromFloat(type, lowerBound, upperBound, step);
        }

        /// <summary>
        /// Indicates that double values between <paramref name="lowerBound"/> and <paramref name="upperBound"/> inclusive should be generated with an increase of <paramref name="step"/> after every value
        /// </summary>
        /// <param name="lowerBound">The value to start generating from</param>
        /// <param name="upperBound">The value to stop generating at</param>
        /// /// <param name="step">The amount to increase the value by at each generation step</param>
        /// <remarks>
        /// If <paramref name="lowerBound"/> is greater than <paramref name="upperBound"/> they will automatically switch.
        /// <paramref name="lowerBound"/> (or <paramref name="upperBound"/> if switched) will always appear in the sequence, however the other parameter will not necessarily appear if it is not in the sequence generated by continually adding <paramref name="step"/>.
        /// </remarks>
        public RangeAttribute(double lowerBound, double upperBound, double step)
        {
            if (step <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepMustBePositive, nameof(step)));
            }

            Generator = type => GetRangeSequenceFromDouble(type, lowerBound, upperBound, step);
        }

        /// <inheritdoc />
        public override IEnumerable<object> GetValues(ParameterInfo parameter)
        {
            var type = parameter.ParameterType;
            if (!type.IsNumericType())
            {
                throw new NotSupportedException(string.Format(Strings.RangeNotNumericType, nameof(RangeAttribute)));
            }

            return Generator(type);
        }

        private static IEnumerable<object> GetRangeSequenceFromLong(Type type, long lowerBound, long upperBound, long step)
        {
            if (type == typeof(byte))
            {
                if (lowerBound < byte.MinValue || lowerBound > byte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "byte"));
                }

                if (upperBound < byte.MinValue || upperBound > byte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "byte"));
                }

                if (step < byte.MinValue || step > byte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "byte"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((byte)lowerBound, (byte)upperBound, (byte)step);
            }
            else if (type == typeof(sbyte))
            {
                if (lowerBound < sbyte.MinValue || lowerBound > sbyte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "sbyte"));
                }

                if (upperBound < sbyte.MinValue || upperBound > sbyte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "sbyte"));
                }

                if (step < sbyte.MinValue || step > sbyte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "sbyte"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((sbyte)lowerBound, (sbyte)upperBound, (sbyte)step);
            }
            else if (type == typeof(ushort))
            {
                if (lowerBound < ushort.MinValue || lowerBound > ushort.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "ushort"));
                }

                if (upperBound < ushort.MinValue || upperBound > ushort.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "ushort"));
                }

                if (step < ushort.MinValue || step > ushort.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "ushort"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((ushort)lowerBound, (ushort)upperBound, (ushort)step);
            }
            else if (type == typeof(short))
            {
                if (lowerBound < short.MinValue || lowerBound > short.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "short"));
                }

                if (upperBound < short.MinValue || upperBound > short.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "short"));
                }

                if (step < short.MinValue || step > short.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "short"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((short)lowerBound, (short)upperBound, (short)step);
            }
            else if (type == typeof(uint))
            {
                if (lowerBound < uint.MinValue || lowerBound > uint.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "uint"));
                }

                if (upperBound < uint.MinValue || upperBound > uint.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "uint"));
                }

                if (step < uint.MinValue || step > uint.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "uint"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((uint)lowerBound, (uint)upperBound, (uint)step);
            }
            else if (type == typeof(int))
            {
                if (lowerBound < int.MinValue || lowerBound > int.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "int"));
                }

                if (upperBound < int.MinValue || upperBound > int.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "int"));
                }

                if (step < int.MinValue || step > int.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "int"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((int)lowerBound, (int)upperBound, (int)step);
            }
            else if (type == typeof(ulong))
            {
                if (lowerBound < 0L)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "ulong"));
                }

                if (upperBound < 0L)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "ulong"));
                }

                if (step < 0L)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "ulong"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((ulong)lowerBound, (ulong)upperBound, (ulong)step);
            }
            else if (type == typeof(long))
            {
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((long)lowerBound, (long)upperBound, (long)step);
            }
            else if (type == typeof(float))
            {
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((float)lowerBound, (float)upperBound, (float)step);
            }
            else if (type == typeof(double))
            {
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((double)lowerBound, (double)upperBound, (double)step);
            }
            else
            {
                // decimal
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((decimal)lowerBound, (decimal)upperBound, (decimal)step);
            }
        }

        private static IEnumerable<object> GetRangeSequenceFromULong(Type type, ulong lowerBound, ulong upperBound, ulong step)
        {
            if (type == typeof(byte))
            {
                if (lowerBound > byte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "byte"));
                }

                if (upperBound > byte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "byte"));
                }

                if (step > byte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "byte"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((byte)lowerBound, (byte)upperBound, (byte)step);
            }
            else if (type == typeof(sbyte))
            {
                if (lowerBound > (ulong)sbyte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "sbyte"));
                }

                if (upperBound > (ulong)sbyte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "sbyte"));
                }

                if (step > (ulong)sbyte.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "sbyte"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((sbyte)lowerBound, (sbyte)upperBound, (sbyte)step);
            }
            else if (type == typeof(ushort))
            {
                if (lowerBound > ushort.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "ushort"));
                }

                if (upperBound > ushort.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "ushort"));
                }

                if (step > ushort.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "ushort"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((ushort)lowerBound, (ushort)upperBound, (ushort)step);
            }
            else if (type == typeof(short))
            {
                if (lowerBound > (ulong)short.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "short"));
                }

                if (upperBound > (ulong)short.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "short"));
                }

                if (step > (ulong)short.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "short"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((short)lowerBound, (short)upperBound, (short)step);
            }
            else if (type == typeof(uint))
            {
                if (lowerBound > uint.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "uint"));
                }

                if (upperBound > uint.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "uint"));
                }

                if (step > uint.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "uint"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((uint)lowerBound, (uint)upperBound, (uint)step);
            }
            else if (type == typeof(int))
            {
                if (lowerBound > int.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "int"));
                }

                if (upperBound > int.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "int"));
                }

                if (step > int.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "int"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((int)lowerBound, (int)upperBound, (int)step);
            }
            else if (type == typeof(ulong))
            {
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((ulong)lowerBound, (ulong)upperBound, (ulong)step);
            }
            else if (type == typeof(long))
            {
                if (lowerBound > long.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(lowerBound), string.Format(Strings.RangeLowerBoundOutOfRange, "long"));
                }

                if (upperBound > long.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(upperBound), string.Format(Strings.RangeUpperBoundOutOfRange, "long"));
                }

                if (step > long.MaxValue)
                {
                    throw new ArgumentOutOfRangeException(nameof(step), string.Format(Strings.RangeStepOutOfRange, "long"));
                }

                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((long)lowerBound, (long)upperBound, (long)step);
            }
            else if (type == typeof(float))
            {
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((float)lowerBound, (float)upperBound, (float)step);
            }
            else if (type == typeof(double))
            {
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((double)lowerBound, (double)upperBound, (double)step);
            }
            else
            {
                // decimal
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((decimal)lowerBound, (decimal)upperBound, (decimal)step);
            }
        }

        private static IEnumerable<object> GetRangeSequenceFromFloat(Type type, double lowerBound, double upperBound, double step)
        {
            if (type.IsIntegerType())
            {
                throw new NotSupportedException(Strings.RangeFloatingNotApplicableToInteger);
            }
            else if (type == typeof(decimal))
            {
                throw new NotSupportedException(Strings.RangeFloatingPointNotApplicableToDecimal);
            }
            else if (type == typeof(float))
            {
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((float)lowerBound, (float)upperBound, (float)step);
            }
            else
            {
                // double
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((double)lowerBound, (double)upperBound, (double)step);
            }
        }

        private static IEnumerable<object> GetRangeSequenceFromDouble(Type type, double lowerBound, double upperBound, double step)
        {
            if (type.IsIntegerType())
            {
                throw new NotSupportedException(Strings.RangeFloatingNotApplicableToInteger);
            }
            else if (type == typeof(decimal))
            {
                throw new NotSupportedException(Strings.RangeFloatingPointNotApplicableToDecimal);
            }
            else if (type == typeof(float))
            {
                throw new NotSupportedException(Strings.RangeDoubleNotApplicableToSingle);
            }
            else
            {
                // double
                if (lowerBound > upperBound)
                {
                    var switchVar = lowerBound;
                    lowerBound = upperBound;
                    upperBound = switchVar;
                }

                return GetRangeSequence((double)lowerBound, (double)upperBound, (double)step);
            }
        }

        private static IEnumerable<object> GetRangeSequence(byte start, byte end, byte step)
        {
            checked
            {
                for (byte i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(sbyte start, sbyte end, sbyte step)
        {
            checked
            {
                for (sbyte i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(ushort start, ushort end, ushort step)
        {
            checked
            {
                for (ushort i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(short start, short end, short step)
        {
            checked
            {
                for (short i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(uint start, uint end, uint step)
        {
            checked
            {
                for (uint i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(int start, int end, int step)
        {
            checked
            {
                for (int i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(ulong start, ulong end, ulong step)
        {
            checked
            {
                for (ulong i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(long start, long end, long step)
        {
            checked
            {
                for (long i = start; i <= end; i += step)
                {
                    yield return (object)i;
                }
            }
        }

        private static IEnumerable<object> GetRangeSequence(float start, float end, float step)
        {
            float i;
            for (i = start; i <= end; i += step)
            {
                yield return (object)i;
            }

            if (float.IsInfinity(i))
            {
                throw new OverflowException();
            }
        }

        private static IEnumerable<object> GetRangeSequence(double start, double end, double step)
        {
            double i;
            for (i = start; i <= end; i += step)
            {
                yield return (object)i;
            }

            if (double.IsInfinity(i))
            {
                throw new OverflowException();
            }
        }

        private static IEnumerable<object> GetRangeSequence(decimal start, decimal end, decimal step)
        {
            for (decimal i = start; i <= end; i += step)
            {
                yield return (object)i;
            }
        }
    }
}
